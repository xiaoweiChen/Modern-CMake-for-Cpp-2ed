当我们成功地将源代码编译成二进制文件，貌似作为构建工程师的角色就完成了。然而，事实并非如此。虽然二进制文件确实包含了CPU执行所需的所有代码，但这些代码以复杂的方式分布在多个文件中。我们不希望CPU在不同的文件中搜索单个代码片段。相反，是要将这些单独的单元合并成一个文件。为了实现这一点，需要使用一个称为“链接”的过程。

CMake的链接命令并不多，其中target\_link\_libraries()其中之一。那为什么还要为单个命令写一整个章节呢？在计算机科学中，几乎没有什么东西是简单的，链接也不例外：为了得到正确的结果，需要对整体进行了解——需要知道链接器如何工作，并且要掌握基础知识。将讨论目标文件的内部结构，如何工作的重定位和引用解析机制，以及其用途。我们将讨论最终可执行文件与组件的不同之处，以及系统在将程序加载到内存时，如何构建进程映像。

然后，介绍各种类型的库：静态库、共享库和共享模块。它们都称为“库”，但又非常不同。创建链接良好的可执行文件，依赖于正确的配置和处理特定细节，例如：位置无关代码（PIC）。

了解链接的另一个难题——唯一定义规则（ODR）。准确地定义符号的数量至关重要。管理重复的符号很具有挑战性，尤其是对于共享库。此外，将探讨为什么链接器有时无法定位外部符号，即使可执行文件已正确链接到相关库。

最后，将了解如何高效地使用链接器，为解决方案在特定框架内进行测试做好准备。

本章中，包含以下内容：

\begin{itemize}
\item
链接的基本知识

\item
构建不同类型的库

\item
解决ODR问题

\item
链接和未解析符号的顺序

\item
为测试分离main()
\end{itemize}











































